/* 
    Macros that enable you to store data in a hashmap.
*/

/// @dev Hash a piece of data, representing a key, to generate the storage slot that the data will be located.
/// @param mem_offset The offset in memory where the raw data will be stored before hashing.
/// Input stack: [key]
/// Output stack: [slot]
#define macro GET_SLOT_FROM_KEY(mem_offset) = takes(1) returns (1) {
    // Load the data into memory and hash it, while preserving the memory location.
    <mem_offset>    // [<mem_offset>, key]
    mstore          // []
    
    // Hash the data, generating a key.
    0x20            // [32]
    <mem_offset>    // [<mem_offset>, 32]
    sha3            // [slot]
}

/// @dev Hash two pieces of data, representing a key and a salt, to generate the storage slot that the data will be located.
/// Note that using a salt when hashing keys is essential when your map has multiple maps.
/// @param mem_offset The offset in memory where the raw data will be stored before hashing.
/// Input stack: [key, salt]
/// Output stack: [slot]
#define macro GET_SLOT_FROM_KEYS(mem_offset) = takes(2) returns (1) {
    // Load the data into memory.
    <mem_offset>            // [<mem_offset>, key1, salt]
    mstore                  // [salt]
    <mem_offset> 0x20 add   // [<mem_offset> + 32, salt]
    mstore                  // []
    
    // Hash the data, generating a key.
    0x40                    // [64]
    <mem_offset>            // [<mem_offset>, 64]
    sha3                    // [slot]
}

/// @dev Given a key, load it's value from storage.
/// @param mem_offset The offset in memory where the raw data will be stored before hashing.
/// Input stack: [key]
/// Output stack: [value]
#define macro LOAD_ELEMENT(mem_offset) = takes(1) returns(1) {
    GET_SLOT_FROM_KEY(<mem_offset>)     // [slot]
    sload                               // [value]
}

/// @dev Given a key and a salt, load their corresponding value from storage.
/// @param mem_offset The offset in memory where the raw data will be stored before hashing.
/// Input stack: [key, salt]
/// Output stack: [value]
#define macro LOAD_ELEMENT_FROM_KEYS(mem_offset) = takes(2) returns(1) {
    GET_SLOT_FROM_KEYS(<mem_offset>) // [slot]
    sload                            // [value]
}

/// @dev Given a key and a value, store the value in the key's corresponding storage slot.
/// @param mem_offset The offset in memory where the raw data will be stored before hashing.
/// Input Stack: [key, value]
/// Output Stack: []
#define macro STORE_ELEMENT(mem_offset) = takes(2) returns(0) {
    GET_SLOT_FROM_KEY(<mem_offset>)     // [slot, value]
    sstore                              // []
}

/// @dev Given a key, salt, and a value, store the value in the key's corresponding storage slot.
/// @param mem_offset The offset in memory where the raw data will be stored before hashing.
/// Input Stack: [key, salt, value]
/// Output Stack: []
#define macro STORE_ELEMENT_FROM_KEYS(mem_offset) = takes(2) returns (0) {
    GET_SLOT_FROM_KEYS(<mem_offset>)    // [slot, value]
    sstore                              // []
}

/// @dev Given a key, store a value (>32 bytes in length) in the key's corresponding storage slot.
/// @param mem_offset The offset in memory where the raw data will be stored before hashing.
/// @param mem_ptr The offset in memory where the value (data to be stored) is located.
/// Input Stack: [key]
/// Output Stack: []
#define macro STORE_BYTES_ELEMENTS_FROM_KEY(mem_offset, mem_ptr) = takes(1) returns (0) {
    // Get the slot from the key and store the length of the bytes array in the slot.
    GET_SLOT_FROM_KEY(<mem_offset>) // [slot]
    <mem_ptr> mload                 // [length, slot]
    dup1 dup3                       // [slot, length, length, slot]
    sstore                          // [length, slot]
    
    // Read the bytes array from memory and store each element to memory.
    0x00    // [i, length, slot]
    loop:
        // Ensure that i is less than the length of the bytes array.
        dup2 dup2   // [i, length, i, length, slot]
        eq          // [i==length, i, length, slot]
        break jumpi // [i, length, slot]

        // Read the element from memory and store it in storage.
        0x01 add                            // [i+1, length, slot]
        dup1                                // [i+1, i+1, length, slot]
        0x20 mul                            // [32*(i+1), i+1, length, slot]
        <mem_ptr>                           // [mem_ptr, 32*(i+1), i+1, length, slot]
        add                                 // [new_mem_ptr, i+1, length, slot]
        mload                               // [element, i+1, length, slot]
        swap2                               // [length, i+1, element, slot]
        dup4                                // [slot, length, i+1, element, slot]
        dup3                                // [i+1, slot, length, i+1, element, slot]
        swap1                               // [slot, i+1, length, i+1, element, slot]
        GET_SLOT_FROM_KEYS(<mem_offset>)    // [new_slot, length, i+1, element, slot]
        swap1 swap3 swap1                   // [new_slot, element, i+1, length, slot]
        sstore                              // [i+1, length, slot]
        loop jump                           // [i+1, length, slot]

    break:
        pop pop pop // []
}

/// @dev Store a bytes value in storage. 
/// @param mem_offset The offset in memory where the raw data will be stored before hashing.
/// @param mem_ptr The offset in memory where the value (data to be stored) is located.
/// Input Stack: [key, salt]
/// Output Stack: []
#define macro STORE_BYTES_ELEMENTS_FROM_KEYS(mem_offset, mem_ptr) = takes(2) returns (0) {
    // Get the slot from the key and store the length of the bytes array in the slot.
    GET_SLOT_FROM_KEYS(<mem_offset>) // [slot]
    <mem_ptr> mload                 // [length, slot]
    dup1 dup3                       // [slot, length, length, slot]
    sstore                          // [length, slot]
    
    // Read the bytes array from memory and store each element to storage.
    0x00    // [i, length, slot]
    loop:
        // Ensure that i is less than the length of the bytes array.
        dup2 dup2   // [i, length, i, length, slot]
        eq          // [i==length, i, length, slot]
        break jumpi // [i, length, slot]

        // Read the element from memory and store it in storage.
        0x01 add                            // [i+1, length, slot]
        dup1                                // [i+1, i+1, length, slot]
        0x20 mul                            // [32*(i+1), i+1, length, slot]
        <mem_ptr>                           // [mem_ptr, 32*(i+1), i+1, length, slot]
        add                                 // [new_mem_ptr, i+1, length, slot]
        mload                               // [element, i+1, length, slot]
        swap2                               // [length, i+1, element, slot]
        dup4                                // [slot, length, i+1, element, slot]
        dup3                                // [i+1, slot, length, i+1, element, slot]
        swap1                               // [slot, i+1, length, i+1, element, slot]
        GET_SLOT_FROM_KEYS(<mem_offset>)    // [new_slot, length, i+1, element, slot]
        swap1 swap3 swap1                   // [new_slot, element, i+1, length, slot]
        sstore                              // [i+1, length, slot]
        loop jump                           // [i+1, length, slot]

    break:
        pop pop pop // []
}

/// @dev Retrieve a bytes value from storage using a single key.
/// @param mem_offset The offset in memory where the raw data will be stored before hashing.
/// @param mem_ptr The offset in memory where the data will be stored.
#define macro LOAD_BYTES_ELEMENT_FROM_KEY(mem_offset, mem_ptr) = takes(1) returns (1) {
    // Get the slot from the key and store the length of the bytes array in the slot.
    GET_SLOT_FROM_KEY(<mem_offset>) dup1    // [slot, slot]
    sload                                   // [length, slot]

    // Read the bytes array from story and store each element to memory.
    0x00    // [i, length, slot]
    
    loop:
        // Input Stack: // [i, length, slot]
        dup2 dup2       // [i, length, i, length, slot]
        eq              // [i==length, i, length, slot]
        break jumpi     // [i, length, slot]

        // Read the data and store it to memory.
        0x01 add                            // [i+1, length, slot]
        dup1                                // [i+1, i+1, length, slot]
        0x20 mul                            // [32*(i+1), i+1, length, slot]
        <mem_ptr> add                       // [new_mem_ptr, i+1, length, slot]
        dup2                                // [i+1, new_mem_ptr, i+1, length, slot]
        dup5                                // [slot, i+1, new_mem_ptr, i+1, length, slot]
        GET_SLOT_FROM_KEYS(<mem_offset>)    // [new_slot, new_mem_ptr, i+1, length, slot]
        sload                               // [element, new_mem_ptr, i+1, length, slot]
        swap1                               // [new_mem_ptr, element, i+1, length, slot] 
        mstore                              // [i+1, length, slot]
        loop jump                           // [i+1, length, slot]

    break:
        pop pop pop
}

/// @dev Retrieve a bytes value from storage using two keys.
/// @param mem_offset The offset in memory where the raw data will be stored before hashing.
/// @param mem_ptr The offset in memory where the data will be stored.
#define macro LOAD_BYTES_ELEMENT_FROM_KEYS(mem_offset, mem_ptr) = takes(2) returns (1) {
    // Get the slot from the key and store the length of the bytes array in the slot.
    GET_SLOT_FROM_KEYS(<mem_offset>) dup1   // [slot, slot]
    sload                                   // [length, slot]

    // Read the bytes array from story and store each element to memory.
    0x00    // [i, length, slot]
    
    loop:
        // Input Stack: // [i, length, slot]
        dup2 dup2       // [i, length, i, length, slot]
        eq              // [i==length, i, length, slot]
        break jumpi     // [i, length, slot]

        // Read the data and store it to memory.
        0x01 add                            // [i+1, length, slot]
        dup1                                // [i+1, i+1, length, slot]
        0x20 mul                            // [32*(i+1), i+1, length, slot]
        <mem_ptr> add                       // [new_mem_ptr, i+1, length, slot]
        dup2                                // [i+1, new_mem_ptr, i+1, length, slot]
        dup5                                // [slot, i+1, new_mem_ptr, i+1, length, slot]
        GET_SLOT_FROM_KEYS(<mem_offset>)    // [new_slot, new_mem_ptr, i+1, length, slot]
        sload                               // [element, new_mem_ptr, i+1, length, slot]
        swap1                               // [new_mem_ptr, element, i+1, length, slot] 
        mstore                              // [i+1, length, slot]
        loop jump                           // [i+1, length, slot]

    break:
        pop pop pop
}