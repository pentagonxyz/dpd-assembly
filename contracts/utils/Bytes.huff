/* 
    Macros that enable you to use arbitrarily lengthed data.
*/

// Given an offset that points to a location in calldata, store the input in memory at the mem_offset.
// This macro will also return the mem_offset incremented by the size of the input, as well as the length of the data (excluding the 32 bytes used to give the length).

// HOLY COW IM DOING THIS WRONG, ITS ACTUALLY MUCH EASIER READ THIS: https://docs.soliditylang.org/en/develop/abi-spec.html#use-of-dynamic-types
#define macro READ_BYTES_FROM_CALLDATA(cd_offset, mem_offset) = takes(0) returns (2) {
    // Input stack: []
    // Read the length from calldata and store it in memory.
    cd_offset calldataload  // [length]
    dup1                    // [length, length]
    mem_offset mstore       // [length]


    // Input stack: [length]
    // Using the length, read the bytes from calldata and store them in memory.
    0x00            // [i, length]
    loop:
        // Input stack: [i, length]
        // End the loop if we have read the entire bytes array.
        dup2 dup2   // [i, length, i, length]
        eq          // [i == length, i, length]
        break jumpi // [i, length]

        // Read from the array and store it to memory.
        0x01 add        // [i+1, length]
        dup1            // [i+1, i+1, length]
        0x20 mul        // [(i+1)*32, i+1, length]
        dup1            // [(i+1)*32, (i+1)*32, i+1, length]
        <cd_offset>     // [cd_offset, (i+1)*32, (i+1)*32, i+1, length]
        add             // [new_cd_offset, (i+1)*32, i+1, length]
        calldataload    // [data, (i+1)*32, i+1, length]
        swap1           // [(i+1)*32, data, i+1, length]
        mem_offset add  // [new_mem_offset, data, i+1, length] 
        mstore          // [i+1, length]

        // Jump to the start of the loop.
        loop jump

    break:
        // Input stack: [length, length]
        // i and length are the same, so are stack is just [length, length]
        0x20 mul            // [length*32, length]
        0x32 add            // [(length + 1)*32, length]
        <mem_offset> add    // [mem_offset + (length+1)*32, length]
        
}